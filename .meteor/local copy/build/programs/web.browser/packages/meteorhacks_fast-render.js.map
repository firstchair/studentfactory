)]}'
{"version":3,"sources":["meteorhacks:fast-render/lib/utils.js","meteorhacks:fast-render/lib/client/fast_render.js","meteorhacks:fast-render/lib/client/debugger.js","meteorhacks:fast-render/lib/client/ddp_update.js","meteorhacks:fast-render/lib/client/auth.js","meteorhacks:fast-render/lib/client/boot.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,6C;AACA,wB;AACA,qB;AACA,oC;;AAEA,0C;AACA,sB;AACA,mD;AACA,gC;AACA,O;AACA,K;AACA,K;AACA,E;;AAEA,wC;AACA,kD;AACA,8B;AACA,iD;AACA,0B;AACA,O;AACA,uC;AACA,iD;AACA,0B;AACA,O;AACA,2C;AACA,yB;AACA,O;AACA,uC;AACA,kB;AACA,G;;AAEA,gB;AACA,E;;AAEA,oD;AACA,oD;AACA,wC;AACA,gC;AACA,oC;AACA,uD;;AAEA,qD;AACA,8B;AACA,8C;AACA,sH;AACA,mC;AACA,S;AACA,2E;AACA,sC;AACA,kE;AACA,W;AACA,S;AACA,kE;AACA,iE;AACA,sF;AACA,kB;AACA,iH;AACA,W;AACA,S;AACA,oE;AACA,mE;AACA,wF;AACA,kB;AACA,4D;AACA,W;AACA,gB;AACA,mC;AACA,S;AACA,O;AACA,K;AACA,K;AACA,a;AACA,E;;;;;;;;;;;;;;;;;;ACxEA,gB;AACA,gE;AACA,iC;AACA,2C;AACA,iF;AACA,0B;AACA,iH;AACA,C;;AAEA,+E;AACA,yB;AACA,kG;AACA,C;;AAEA,6E;AACA,2D;AACA,2D;AACA,oB;AACA,uD;AACA,gE;AACA,gD;AACA,yD;AACA,+B;AACA,4C;AACA,E;;AAEA,qC;AACA,iC;;AAEA,qC;;AAEA,0D;AACA,qC;AACA,kC;AACA,gC;;AAEA,8C;AACA,mD;AACA,mB;AACA,8D;AACA,4B;AACA,6B;AACA,K;AACA,iC;;AAEA,uC;AACA,sC;AACA,iC;AACA,oC;AACA,gB;AACA,+C;AACA,S;AACA,S;AACA,O;AACA,K;;AAEA,gD;AACA,yC;AACA,sD;AACA,sB;;AAEA,wB;AACA,qB;AACA,6B;AACA,e;AACA,qB;AACA,mB;AACA,Q;;AAEA,iE;AACA,O;AACA,K;;AAEA,2D;AACA,sC;AACA,kC;AACA,G;AACA,E;;AAEA,+C;AACA,0B;AACA,mF;AACA,sD;AACA,kG;AACA,K;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;ACtFA,4B;AACA,kC;AACA,0E;AACA,K;AACA,oC;AACA,kD;AACA,oD;AACA,G;AACA,iD;AACA,yC;AACA,0C;AACA,G;AACA,C;;AAEA,8C;AACA,+C;AACA,oB;AACA,E;;AAEA,8C;AACA,6C;AACA,oB;AACA,E;;AAEA,6C;AACA,sC;AACA,E;;AAEA,iD;AACA,sD;AACA,E;;AAEA,8C;AACA,oD;AACA,oB;AACA,E;;AAEA,gD;AACA,kD;AACA,oB;AACA,E;;AAEA,+C;AACA,mD;AACA,oB;AACA,E;;AAEA,8C;AACA,iD;AACA,oB;AACA,E;;AAEA,gD;AACA,6B;AACA,E;;AAEA,oD;AACA,6C;AACA,E;;;;;;;;;;;;;;;;;;;AC1DA,yB;;AAEA,4D;AACA,kD;AACA,0C;AACA,6D;AACA,W;AACA,I;AACA,sD;AACA,wE;AACA,0C;AACA,I;AACA,mE;AACA,yE;AACA,I;AACA,yE;AACA,0E;AACA,uC;AACA,I;AACA,6E;;AAEA,0B;AACA,8C;AACA,2D;AACA,I;AACA,qC;AACA,6E;AACA,8E;AACA,2B;AACA,sD;AACA,yB;AACA,iE;AACA,2C;AACA,S;AACA,sC;AACA,6B;AACA,wE;AACA,kC;AACA,W;;AAEA,kD;AACA,qD;AACA,W;AACA,Q;AACA,uB;AACA,iE;AACA,yC;AACA,S;AACA,O;AACA,K;AACA,G;;AAEA,8D;AACA,uE;;AAEA,oE;AACA,8C;AACA,uE;AACA,wC;AACA,gE;AACA,0B;AACA,4F;AACA,yD;AACA,yD;AACA,sD;AACA,S;AACA,S;AACA,K;;AAEA,oD;AACA,yC;AACA,qD;AACA,8D;AACA,gD;AACA,K;AACA,G;;AAEA,8C;AACA,E;;AAEA,2C;AACA,yC;AACA,+E;AACA,8C;AACA,uE;AACA,yD;AACA,wD;AACA,8C;AACA,wB;AACA,G;;AAEA,kB;;AAEA,8D;AACA,uE;AACA,0B;AACA,yB;AACA,0C;;AAEA,8D;AACA,0B;AACA,0E;AACA,kF;AACA,8C;AACA,uD;AACA,K;AACA,G;;AAEA,sC;AACA,E;;;;;;;;;;;;;;;;;;;AC7GA,oC;AACA,2D;AACA,6C;AACA,2B;AACA,e;AACA,G;;AAEA,mE;AACA,mD;AACA,qD;AACA,kC;AACA,6B;AACA,G;AACA,yD;AACA,E;;AAEA,yD;AACA,iD;AACA,kC;AACA,6B;AACA,G;AACA,qD;AACA,C;;AAEA,uB;AACA,qE;AACA,6F;;AAEA,kB;AACA,4C;AACA,U;AACA,uB;AACA,G;AACA,C;;AAEA,wC;AACA,gD;AACA,c;AACA,oB;AACA,K;AACA,C;;;;;;;;;;;;;;;;;;ACxCA,0D;AACA,2B;AACA,G","file":"/packages/meteorhacks_fast-render.js","sourcesContent":["AddedToChanged = function(localCopy, added) {\n  added.msg = \"changed\";\n  added.cleared = [];\n  added.fields = added.fields || {};\n\n  _.each(localCopy, function(value, key) {\n    if(key != '_id') {\n      if(typeof added.fields[key] == \"undefined\") {\n        added.cleared.push(key);\n      }\n    }\n  });\n};\n\nApplyDDP = function(existing, message) {\n  var newDoc = (!existing)? {}: _.clone(existing);\n  if(message.msg == 'added') {\n    _.each(message.fields, function(value, key) {\n      newDoc[key] = value;\n    });\n  } else if(message.msg == \"changed\") {\n    _.each(message.fields, function(value, key) {\n      newDoc[key] = value;\n    });\n    _.each(message.cleared, function(key) {\n      delete newDoc[key];\n    });\n  } else if(message.msg == \"removed\") {\n    newDoc = null;\n  }\n\n  return newDoc;\n};\n\n// source: https://gist.github.com/kurtmilam/1868955\n//  modified a bit to not to expose this as an _ api\nDeepExtend = function deepExtend (obj) {\n  var parentRE = /#{\\s*?_\\s*?}/,\n      slice = Array.prototype.slice,\n      hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  _.each(slice.call(arguments, 1), function(source) {\n    for (var prop in source) {\n      if (hasOwnProperty.call(source, prop)) {\n        if (_.isUndefined(obj[prop]) || _.isFunction(obj[prop]) || _.isNull(source[prop]) || _.isDate(source[prop])) {\n          obj[prop] = source[prop];\n        }\n        else if (_.isString(source[prop]) && parentRE.test(source[prop])) {\n          if (_.isString(obj[prop])) {\n            obj[prop] = source[prop].replace(parentRE, obj[prop]);\n          }\n        }\n        else if (_.isArray(obj[prop]) || _.isArray(source[prop])){\n          if (!_.isArray(obj[prop]) || !_.isArray(source[prop])){\n            throw 'Error: Trying to combine an array with a non-array (' + prop + ')';\n          } else {\n            obj[prop] = _.reject(DeepExtend(obj[prop], source[prop]), function (item) { return _.isNull(item);});\n          }\n        }\n        else if (_.isObject(obj[prop]) || _.isObject(source[prop])){\n          if (!_.isObject(obj[prop]) || !_.isObject(source[prop])){\n            throw 'Error: Trying to combine an object with a non-object (' + prop + ')';\n          } else {\n            obj[prop] = DeepExtend(obj[prop], source[prop]);\n          }\n        } else {\n          obj[prop] = source[prop];\n        }\n      }\n    }\n  });\n  return obj;\n};","FastRender = {};\nFastRender.enabled = typeof __fast_render_config != 'undefined';\nFastRender._dataReceived = false;\nFastRender._revertedBackToOriginal = false;\nFastRender._blockDDP = Meteor._localStorage.getItem('__frblockddp') != undefined;\nif(FastRender._blockDDP) {\n  console.log(\"FastRender is blocking DDP messages. apply 'FastRender.debugger.unblockDDP()' to unblock again.\");\n}\n\nFastRender._disable = Meteor._localStorage.getItem('__frdisable') != undefined;\nif(FastRender._disable) {\n  console.log(\"FastRender is disabled. apply 'FastRender.debugger.enableFR()' to enable it back.\")\n}\n\n// This allow us to apply DDP message even if Meteor block accepting messages\n//  When doing initial login, Meteor sends an login message\n//  Then it'll block the accpeting DDP messages from server\n//  This is the cure\nFastRender.injectDdpMessage = function(conn, message) {\n  FastRender[\"debugger\"].log('injecting ddp message:', message);\n  var originalWait = conn._waitingForQuiescence;\n  conn._waitingForQuiescence = function() {return false};\n  conn._livedata_data(message);\n  conn._waitingForQuiescence = originalWait;\n};\n\nFastRender.init = function(payload) {\n  if(FastRender._disable) return;\n\n  FastRender._securityCheck(payload);\n\n  FastRender._subscriptions = payload.subscriptions || {};\n  FastRender._subscriptionIdMap = {};\n  FastRender._dataReceived = true;\n  FastRender._payload = payload;\n\n  // merging data from different subscriptions\n  //  yes, this is a minimal mergeBox on the client\n  var allData = {};\n  _.each(payload.collectionData, function(subData, collName) {\n    if(!allData[collName]) {\n      allData[collName] = {};\n    }\n    collData = allData[collName];\n\n    subData.forEach(function(dataSet) {\n      dataSet.forEach(function(item) {\n        if(!collData[item._id]) {\n          collData[item._id] = item;\n        } else {\n          DeepExtend(collData[item._id], item);\n        }\n      });\n    });\n  });\n\n  _.each(allData, function(collData, collName) {\n    _.each(collData, function(item, id) {\n      var id = LocalCollection._idStringify(item._id);\n      delete item._id;\n\n      var ddpMessage = {\n        msg: 'added',\n        collection: collName,\n        id: id,\n        fields: item,\n        frGen: true\n      };\n\n      FastRender.injectDdpMessage(Meteor.connection, ddpMessage);\n    });\n  });\n\n  // let Meteor know, user login process has been completed\n  if(typeof Accounts != 'undefined') {\n    Accounts._setLoggingIn(false);\n  }\n};\n\nFastRender._securityCheck = function(payload) {\n  if(payload.loginToken) {\n    var localStorageLoginToken = Meteor._localStorage.getItem('Meteor.loginToken');\n    if(localStorageLoginToken != payload.loginToken) {\n      throw new Error(\"seems like cookie tossing is happening. visit here: http://git.io/q4IRHQ\");\n    }\n  }\n};","FastRender[\"debugger\"] = {};\nFastRender[\"debugger\"]._logs = [];\nFastRender[\"debugger\"].log = function function_name(message/*, args..*/) {\n  if(\n    typeof console != 'undefined' &&\n    typeof Meteor._localStorage != 'undefined' && \n    Meteor._localStorage.getItem('__frlog') == \"1\") \n  {\n    FastRender[\"debugger\"]._logs.push(arguments);\n    arguments[0] = \"FR: \" + arguments[0];\n    console.log.apply(console, arguments);\n  }\n}\n\nFastRender[\"debugger\"].showLogs = function() {\n  Meteor._localStorage.setItem('__frlog', \"1\");\n  location.reload();\n};\n\nFastRender[\"debugger\"].hideLogs = function() {\n  Meteor._localStorage.removeItem('__frlog');\n  location.reload();\n};\n\nFastRender[\"debugger\"].getLogs = function() {\n  return FastRender[\"debugger\"]._logs;\n};\n\nFastRender[\"debugger\"].getLogsJSON = function() {\n  return JSON.stringify(FastRender[\"debugger\"]._logs);\n};\n\nFastRender[\"debugger\"].blockDDP = function() {\n  Meteor._localStorage.setItem('__frblockddp', \"1\");\n  location.reload();\n};\n\nFastRender[\"debugger\"].unblockDDP = function() {\n  Meteor._localStorage.removeItem('__frblockddp');\n  location.reload();\n};\n\nFastRender[\"debugger\"].disableFR = function() {\n  Meteor._localStorage.setItem('__frdisable', \"1\");\n  location.reload();\n};\n\nFastRender[\"debugger\"].enableFR = function() {\n  Meteor._localStorage.removeItem('__frdisable');\n  location.reload();\n};\n\nFastRender[\"debugger\"].getPayload = function() {\n  return FastRender._payload;\n};\n\nFastRender[\"debugger\"].getPayloadJSON = function() {\n  return JSON.stringify(FastRender._payload);\n};\n","var reconnecting = false;\n\nvar originalLivedataData = Meteor.connection._livedata_data;\nMeteor.connection._livedata_data = function(msg) {\n  if(FastRender._blockDDP && !msg.frGen) {\n    FastRender[\"debugger\"].log('blocking incoming ddp', msg);\n    return;\n  };\n  // fast-render adds data manually while initializing\n  // But when the server sends actual data via DDP, it also tries to add\n  // Then we need to detect that and alter\n  //\n  // But we don't need to interfer with Meteor's simulation process\n  // That's why we are checking for serverDocs and ignore manual handling\n  //\n  // We don't need this logic after our special handling reverted back to\n  // original. But we can't detect when null publications completed or not\n  // That's why we need keep this logic\n  //\n  // It's okay to ignore this logic after sometime, but not sure when exactly\n\n  if(msg.msg == 'added') {\n    var id = LocalCollection._idParse(msg.id);\n    var serverDoc = this._getServerDoc(msg.collection, id);\n    \n    if(!reconnecting && !serverDoc) {\n      var localCollection = this._mongo_livedata_collections[msg.collection];\n      var pendingStoreUpdates = this._updatesForUnknownStores[msg.collection];\n      if(localCollection) {\n        var existingDoc = localCollection.findOne(id);\n        if(existingDoc) {\n          FastRender[\"debugger\"].log('re writing DDP for:', msg);\n          AddedToChanged(existingDoc, msg);\n        }\n      } else if(pendingStoreUpdates) {\n        var mergedDoc = null;\n        var existingDocs = _.filter(pendingStoreUpdates, function(doc) {\n          return doc.id == msg.id;\n        });\n\n        _.each(existingDocs, function(cachedMsg) {\n          mergedDoc = ApplyDDP(mergedDoc, cachedMsg);\n        });\n        \n        if(mergedDoc) {\n          FastRender[\"debugger\"].log('re writing DDP for:', msg);\n          AddedToChanged(mergedDoc, msg);\n        }\n      }\n    }\n  }\n\n  // if we've completed our tasks, no need of special handling\n  if(!FastRender._revertedBackToOriginal && FastRender._dataReceived) {\n\n    // This will take care of cleaning special subscription handling\n    // after the actual subscription comes out\n    if(msg.msg == 'ready' && !msg.frGen && FastRender._subscriptions) {\n      msg.subs.forEach(function(subId) {\n        var subscription = FastRender._subscriptionIdMap[subId];\n        if(subscription) {\n          FastRender[\"debugger\"].log('actual subscription completed:', subscription, subId);\n          // we don't need to handle specially after this\n          delete FastRender._subscriptions[subscription];\n          delete FastRender._subscriptionIdMap[subId];\n        }\n      });\n    }\n\n    // if all the subscriptions have been processed,\n    // there is no need to keep hijacking\n    if(EJSON.equals(FastRender._subscriptions, {})) {\n      FastRender[\"debugger\"].log('fast rendering completed!');\n      FastRender._revertedBackToOriginal = true;\n    }\n  }\n\n  return originalLivedataData.call(this, msg);\n};\n\nvar originalSend = Meteor.connection._send;\nMeteor.connection._send = function(msg) {\n  // if looking for connect again to the server, we must need to revert back to\n  // original to prevent some weird DDP issues\n  //  normally it is already reverted, but user may added subscriptions\n  //  in server, which are not subscribed from the client\n  if(msg.msg == 'connect' && msg.session != undefined) {\n    FastRender._revertedBackToOriginal = true;\n    reconnecting = true;\n  }\n\n  var self = this;\n\n  // if we've completed our tasks, no need of special handling\n  if(!FastRender._revertedBackToOriginal && FastRender._dataReceived) {\n    var canSendFakeReady =\n      msg.msg == 'sub' &&\n      FastRender._subscriptions[msg.name];\n\n    FastRender[\"debugger\"].log('new subscription:', msg.name);\n    if(canSendFakeReady) {\n      FastRender[\"debugger\"].log('sending fake ready for sub:', msg.name);\n      FastRender.injectDdpMessage(self, {msg:\"ready\",subs:[msg.id], frGen: true});\n      // add the messageId to be handled later\n      FastRender._subscriptionIdMap[msg.id] = msg.name;\n    }\n  }\n\n  return originalSend.call(this, msg);\n};\n","// getting tokens for the first time\n//  Meteor calls Meteor._localStorage.setItem() on the boot\n//  But we can do it ourselves also with this\nMeteor.startup(function() {\n  resetToken();\n});\n\n// override Meteor._localStorage methods and resetToken accordingly\nvar originalSetItem = Meteor._localStorage.setItem;\nMeteor._localStorage.setItem = function(key, value) {\n  if(key == 'Meteor.loginToken') {\n    Meteor.defer(resetToken);\n  }\n  originalSetItem.call(Meteor._localStorage, key, value);\n};\n\nvar originalRemoveItem = Meteor._localStorage.removeItem;\nMeteor._localStorage.removeItem = function(key) {\n  if(key == 'Meteor.loginToken') {\n    Meteor.defer(resetToken);\n  }\n  originalRemoveItem.call(Meteor._localStorage, key);\n}\n\nfunction resetToken() {\n  var loginToken = Meteor._localStorage.getItem('Meteor.loginToken');\n  var loginTokenExpires = new Date(Meteor._localStorage.getItem('Meteor.loginTokenExpires'));\n\n  if(loginToken) {\n    setToken(loginToken, loginTokenExpires);\n  } else {\n    setToken(null, -1);\n  }\n}\n\nfunction setToken(loginToken, expires) {\n  Cookie.set('meteor_login_token', loginToken, {\n    path: '/',\n    expires: expires\n  });\n}","InjectData.getData('fast-render-data', function(payload) {\n  FastRender.init(payload);\n});"]}